package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"

	"github.com/semanser/ai-coder/executor"
	gmodel "github.com/semanser/ai-coder/graph/model"
	"github.com/semanser/ai-coder/graph/subscriptions"
	"github.com/semanser/ai-coder/models"
	"gorm.io/datatypes"
	"gorm.io/gorm"
)

// CreateFlow is the resolver for the createFlow field.
func (r *mutationResolver) CreateFlow(ctx context.Context) (*gmodel.Flow, error) {
	flow := models.Flow{
		Name: "New Task",
	}

	tx := r.Db.Create(&flow)

	if tx.Error != nil {
		return nil, tx.Error
	}

	return &gmodel.Flow{
		ID:   flow.ID,
		Name: flow.Name,
	}, nil
}

// CreateTask is the resolver for the createTask field.
func (r *mutationResolver) CreateTask(ctx context.Context, flowID uint, query string) (*gmodel.Task, error) {
	type InputTaskArgs struct {
		Query string `json:"query"`
	}

	args := InputTaskArgs{Query: query}
	arg, err := json.Marshal(args)
	if err != nil {
		return nil, err
	}

	task := models.Task{
		Type:    models.Input,
		Message: query,
		Status:  models.Finished,
		Args:    datatypes.JSON(arg),
		FlowID:  flowID,
	}

	tx := r.Db.Create(&task)

	if tx.Error != nil {
		return nil, fmt.Errorf("failed to create task: %w", tx.Error)
	}

	executor.AddCommand(task)

	if err != nil {
		return nil, fmt.Errorf("failed to execute command: %w", err)
	}

	return &gmodel.Task{
		ID:        task.ID,
		Message:   task.Message,
		Type:      gmodel.TaskType(task.Type),
		Status:    gmodel.TaskStatus(task.Status),
		Args:      task.Args.String(),
		CreatedAt: task.CreatedAt,
	}, nil
}

// Exec is the resolver for the _exec field.
func (r *mutationResolver) Exec(ctx context.Context, containerID string, command string) (string, error) {
	b := bytes.Buffer{}
	executor.ExecCommand(containerID, command, &b)

	return b.String(), nil
}

// Flows is the resolver for the flows field.
func (r *queryResolver) Flows(ctx context.Context) ([]*gmodel.Flow, error) {
	flows := []models.Flow{}

	tx := r.Db.Model(&models.Flow{}).Order("created_at DESC").Preload("Tasks").Find(&flows)

	if tx.Error != nil {
		return nil, fmt.Errorf("failed to fetch flows: %w", tx.Error)
	}

	var gFlows []*gmodel.Flow

	for _, flow := range flows {
		var gTasks []*gmodel.Task

		for _, task := range flow.Tasks {
			gTasks = append(gTasks, &gmodel.Task{
				ID:        task.ID,
				Message:   task.Message,
				Type:      gmodel.TaskType(task.Type),
				Status:    gmodel.TaskStatus(task.Status),
				Args:      task.Args.String(),
				Results:   task.Results,
				CreatedAt: task.CreatedAt,
			})

		}

		gFlows = append(gFlows, &gmodel.Flow{
			ID:            flow.ID,
			Name:          flow.Name,
			ContainerName: flow.DockerImage,
			Tasks:         gTasks,
		})
	}

	return gFlows, nil
}

// Flow is the resolver for the flow field.
func (r *queryResolver) Flow(ctx context.Context, id uint) (*gmodel.Flow, error) {
	flow := models.Flow{}

	tx := r.Db.First(&models.Flow{}, id).Preload("Tasks", func(db *gorm.DB) *gorm.DB {
		return db.Order("tasks.created_at ASC")
	}).Find(&flow)

	if tx.Error != nil {
		return nil, fmt.Errorf("failed to fetch flows: %w", tx.Error)
	}

	var gFlow *gmodel.Flow
	var gTasks []*gmodel.Task

	for _, task := range flow.Tasks {
		gTasks = append(gTasks, &gmodel.Task{
			ID:        task.ID,
			Message:   task.Message,
			Type:      gmodel.TaskType(task.Type),
			Status:    gmodel.TaskStatus(task.Status),
			Args:      task.Args.String(),
			Results:   task.Results,
			CreatedAt: task.CreatedAt,
		})
	}

	gFlow = &gmodel.Flow{
		ID:            flow.ID,
		Name:          flow.Name,
		Tasks:         gTasks,
		ContainerName: flow.DockerImage,
	}

	return gFlow, nil
}

// TaskAdded is the resolver for the taskAdded field.
func (r *subscriptionResolver) TaskAdded(ctx context.Context, flowID uint) (<-chan *gmodel.Task, error) {
	return subscriptions.TaskAdded(ctx, flowID)
}

// TaskUpdated is the resolver for the taskUpdated field.
func (r *subscriptionResolver) TaskUpdated(ctx context.Context) (<-chan *gmodel.Task, error) {
	panic(fmt.Errorf("not implemented: TaskUpdated - taskUpdated"))
}

// FlowUpdated is the resolver for the flowUpdated field.
func (r *subscriptionResolver) FlowUpdated(ctx context.Context, flowID uint) (<-chan *gmodel.Flow, error) {
	return subscriptions.FlowUpdated(ctx, flowID)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *mutationResolver) StopTask(ctx context.Context, id uint) (*gmodel.Task, error) {
	panic(fmt.Errorf("not implemented: StopTask - stopTask"))
}
